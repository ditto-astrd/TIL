## 출처 
- [만들면서 배우는 클린 아키텍처]()에서 핵심 내용을 발췌

----

- - 13p
	- SOLID의 SRP : 하나의 컴포넌트는 오로지 한가지 일만 해야하고 그것을 올바르게 수행해야 함
		- 이에 대한 실제 해석은 '컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다'
![[Pasted image 20240910153612.png]]
![[Pasted image 20240910154010.png]]
- 각 이미지 : 18p, 20p 
- 19P
	- 클린 아키텍쳐에서는 도메인 계층이 영속성이나 UI 같은 외부 계층과 철저히 분리돼야 하므로, 어플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수 해야한다.
- 46p
	- '출금 계좌는 초과 인출되어서는 안된다'와 같은 비즈니스 규칙은 도메인 엔티티 안에 넣자
	- 도메인이 비즈니스 로직의 주도권을 가지고 개발하는 것을 도메인 주도 설계 -> [김영한님 언급](https://velog.io/@kevin_/%EC%97%94%ED%8B%B0%ED%8B%B0%EC%97%90-%EB%B9%84%EC%A6%88%EB%8B%88%EC%8A%A4-%EB%A1%9C%EC%A7%81-%EC%B0%AC%EB%B0%98)
	- 다만 엔티티에 비즈니스 로직을 넣지 말지는 각각 장단점이 있으므로, 상황에 맞게 설계하면 됨
- 50p
	- `Interface XXXQuery` vs `Interface XXXUseCase`
		- 둘다 모델의 상태를 변경하는 인터페이스
		- 전자는 거의 읽기 전용 (어플리케이션 코어 관점에서 간단한 데이터 쿼리)
		- 후자는 도메인 로직이 포함됨
			- 단, 입력 유효성 검증까지는 가지 말자. 코드가 오염된다 (15p)
			- 입력 유효성 검증을 추가적으로 하고싶으면 `command` 클래스를 생성하자 
			  (위치 : application > port > in)
	- `XXXQuery`와 `XXXUseCase`로 분리하는 관점은 `CQRS`의 관계와 맞물림
		- CQRS = Command and Query Responsibility Segregation
		- 간단하게 요약하면 CRUD에서 CUD(Command)와 R(Query)을 구분하자는 개념
- 57p
	- 컨트롤러 설계시, 전통적인 MVC처럼 하나의 Controller에 몰아서 작성할 필요가 없음
	- 컨트롤러는 너무 적은것 보다는 너무 많은게 나으며, 가능한 좁고 다른 컨트롤러와 가능한 적게 공유하는 웹 어댑터 조각을 구현해야함 

---
### 전통적인 MVC 아키텍쳐와 비교
- 전통 MVC 구조
	- (5p) 서비스 레이어가 비대해진다
	- (2p) 계층형 아키텍처는 DB 주도 설계를 유도한다.
		- (의존 흐름) 웹 계층 -> 도메인 계층 -> 영속성 계층 (DB)
		- 상태(state)가 아닌 행동(behavior)을 중심으로 모델링 해야한다. 행동이 상태를 바꾸는 주체이기 때문에 결국 행동이 비즈니스를 이끈다.
			- 그렇다면 '도메인 로직'이 아닌 'DB'를 토대로 아키텍쳐를 만드는 것은 모순적이다.
		- 영속성 계층과 도메인 계층 사이에 강한 결합이 생기면 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고, 이로 인해 도메인 로직 뿐만 아니라 즉시 로딩, 지연 로딩, DB 트랜잭션, 캐시 플러시 등 영속성 계층과 관련된 작업을 해야한다.
			- 이로 인해 영속성 코드가 사실상 도메인 코드에 녹아들어가서 둘 중 하나만 바꾸는 것이 어려워 진다.
	- (10p) 개별 개발이 어려워 진다.
		- 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기 어렵다. (코드 병합시 충돌 가능성 높음)
			- 이 경우엔 특정 기능을 동시에 1명에 개발자만 개발 가능
	- (10p) 결국 유지보수하기 쉬운 아키텍쳐를 설계하기 위해 DDD + Hexagonal Architecture 개념이 나옴
- Controller 예시
	- 전통적인 MVC에 기반한 구조는 58p의 코드와 같음
		- 반환 DTO가 `AccountResource` 모델 클래스로 통일 및 공유되고 있음
		- TC 분리가 까다로움
		- 한 눈에 코드가 안들어옴 (어떤 메서드가 어떤 서비스 레이어와 관계가 있는지 등)
	- 따라서 DDD & Hexagonal의 구조에 따라, `SendMoneyController` 라는 단일 컨트롤러를 생성
		- 인수 테스트 작성에 용이함
		- 어떤 service를 참조하는지 한 눈에 들어옴
	- 결론적으로 초반에 DDD & Hexagonal Architecture를 설계하는데 공수가 더 들지만, 유지보수에는 보다 많은 장점이 있음
